---
title: LeetCode Contest No.132
comment: true
toc: true
tags:
  - LeetCode
  - Algorithm
abbrlink: d064e371
updated: 2019-04-16 00:04:27
---


## Contest 132

通过：3/4  排名：99/1047  0:59:44  1WA

最后一道题规定时间内没有做出来，超时7分钟做出来的，无错误提交（似乎）。

这次竞赛感觉看完题都比较虚，但是其实做题之后的效果比预想的好，虽然最后一道题规定时间内没有做出来，但是感觉可以接受，也是很久没有出过 hard 的题目了，这次的 hard 题目实现的相当的。。。。复杂且乱，但是能做出来就是好事。
### No.5024 [除数博弈](https://leetcode-cn.com/contest/weekly-contest-132/problems/divisor-game/)

1WA

看到这个题，感觉可能是动态规划后，第一个想法：动态规划都是简单的题了啊！

是的，这道题还花了整整20分钟才做出来，感觉其中十分钟浪费在了不可置信上和另外一些事情上。。。这次做竞赛太不专心了，批评一下自己，竞赛还是要好好做的。

实现思路上没啥可说的，就是动态规划的思路，从小到大依次遍历所有约数对应的```N-x```的值，所有约数全部为 true 的时候，这时无论先手做如何操作，对方都是必胜的情况，所以这时的 N 为 false ，其余所有情况均为 true ，只需要在每一步操作时将 N 的值变为对应的 false 的 ```N-x``` 的值即可。

  <!-- more -->
### No.5030 [节点与其祖先之间的最大差值](https://leetcode-cn.com/contest/weekly-contest-132/problems/maximum-difference-between-node-and-ancestor/)

一开始脑袋有点乱，想用 pair<int,int> 去实现同时寻找最大值最小值，但是思路一直没有理顺，抱着这次竞赛就放弃了的态度（。。。。）就想着先只写一个 max 吧，很快完成之后，同样的方法复制一份 min ，游戏结束。

思路：后序遍历，先左后右找最大最小值，然后向上计算最大差值，重复循环即可。

注：这里的最大最小值是需要跟着遍历走的，而且必须是后序遍历，这样才不会左右子树之间的最大最小值互串。

### No.5025 [最长等差数列](https://leetcode-cn.com/contest/weekly-contest-132/problems/longest-arithmetic-sequence/)

最没想到的一道题，看完题目毫无思路，而且感觉以前见过类似的题，但是没有做，也没有去找答案怎么实现，感觉自己栽在了自己的手上。按照上一道题的破罐子破摔的思路，想着就用朴素方法做吧，最后一道 hard 的题目看着也不面善，这个至少朴素方法的思路还是有的，甚至实现后都没怎么跑例子测试，没想到直接通过了。思路也没啥思路，暴力搜索。

TODO: 认真去看看别人的实现，回来写一下思路。

### No.5031 [从先序遍历还原二叉树](https://leetcode-cn.com/contest/weekly-contest-132/problems/recover-a-tree-from-preorder-traversal/)

好可惜的题，有了思路之后只剩下不到二十分钟了，然后最后快到时的时候其实主要思路也完成了，缺少一个判断，没有理清楚逻辑放在哪里，生生拖到七分钟。

字符串！字符串！字符串！重要的事情，唉，说三遍也不管用，不知道第几次栽在字符串上面了，但是我的字符串水平还是停留在磕磕绊绊能实现上。用了一个超复杂的方式把原始字符串的数据整齐的摆放在了一个 vector<pair<int,int>> 当中，嗯，是我做事情的风格，东西要摆整齐。后面遍历问题倒是不大。

用一个 stack 保存当前处理的 TreeNode 节点，并留一个变量保存当前深度，对每一个新的数字，判断深度的关系:。情况1：如果新数是当前节点的下一层，判断当前节点的左子树是否为空，为空的话放在左子树，否则放在右子树。情况2：如果新数是当前节点的层数或者更高层，从 stack 中取出上一个保存的节点，并且深度-1，直到满足情况1为止。情况3：如果新数是当前节点的下一层以下，将当前处理的节点推入 stack 中，并且深度+1，这时需要判断当前节点的右子树是否为空 ，如果为空的话当前节点等于当前节点的左子树，否则为当前节点的右子树，直到满足情况1为止。

看到这里，我居然又忘记为什么这么判断了，唔，应该是因为原始数据为先序遍历的结果，所以新数如果比当前节点的子节点更深的话，有两种情况。一种是先序遍历的左子树，这时候左子树有值，右子树为空，那下一个处理的节点必定为左子树。另一种情况是之前经过了情况2后当前处理的节点上升到了该层，这时候当前层的左子树已经处理完毕了， 所以如果右子树不为空的话，当前要处理的必定在右子树内。

好了，什么乱七八糟的，因为是先序遍历，先输出再遍历左再遍历右，所以如果右子树有数的话，必定左子树是完整的了，所以如果右子树不为空，就继续处理右子树，否则处理左子树。OVER。

---

这次竞赛给我的感觉就是，感觉这道题应该有更好的办法吧，感觉这样实现好蠢，但是一时半会又想不到好的解决办法，最后直接使用朴素方法去实现，但是也没想到，其实朴素实现的结果都还不错，至少通过了，也没有出现超时的现象，虽然这个不应该是目标，目标应该是和我的能力之间有一段距离的，这样才能够得到提升。但是也告诉了我一个现在我做题时的一个不太好的想法，一直去寻找方法，而忽略朴素的实现方法，所以经常有时候一道题看了看没有好思路就一直放着，放很久都没有做。这样做一下竞赛，对自己有压力了，不得不做了，就会着急不管用什么方法先做出来再说，也会让自己踏实一些。


PS: 再碎碎念一下，过年的时候报名的比赛，居然忘记比了！居然忘记比了！！！简直了，当时就感觉这么久以后的事情到时候可能会忘记吧，果然不假。
